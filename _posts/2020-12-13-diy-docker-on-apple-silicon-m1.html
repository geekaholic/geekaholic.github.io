---
layout: post
title: " DIY Docker on Apple silicon M1"
date: '2020-12-13T21:13:00.008-06:00'
author: geekaholic
tags:
- docker
- apple-silicon
- virtualization
modified_time: '2020-12-20T01:53:50.732-06:00'
thumbnail: https://1.bp.blogspot.com/-VVMY436xVtQ/X9aQFwHUTTI/AAAAAAAAUZw/rHeLkAWALVwIVIj82MshhUflPl9_9SKgwCLcBGAsYHQ/s72-c/9e9.gif
blogger_id: tag:blogger.com,1999:blog-8947964.post-5800738241893695161
blogger_orig_url: https://www.geekaholic.org/2020/12/diy-docker-on-apple-silicon-m1.html
---

<div class="separator"><div class="separator" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em; text-align: center;"><img border="0" data-original-height="281" data-original-width="500" src="https://1.bp.blogspot.com/-VVMY436xVtQ/X9aQFwHUTTI/AAAAAAAAUZw/rHeLkAWALVwIVIj82MshhUflPl9_9SKgwCLcBGAsYHQ/s320/9e9.gif" width="320" /></div></div><p>When Apple announced the transition to Apple's own ARM-based silicon, I was ecstatic! I've always enjoyed tinkering with ARM based single-board computers such as the raspberry pi 4 and Pinebook Pro. But they always had sub-par performance and here was Apple trying to transition their entire lineup!</p> <p>Even though we all knew the performance should be good based on how recent iPad Pros scored, I don't think many expected the M1 chip, Apple's first iteration, to then beat Intel's most high-end CPUs while redefining "all-day battery life"!</p> <p>So naturally, I found myself clicking buy on day 1, something I rarely do before doing a ton of research. I ended up ordering the base Macbook Air but bumping up the RAM to 16GB in order to better run Docker.</p> <p></p> <h2>Disappointment: Docker support not ready</h2><p>My machine arrived quickly, despite getting shipped directly from China as a result of my memory upgrade. The first step was to setup the environment just the way I liked using <a href="http://github.com/geekaholic/install-buddy" target="_blank">InstallBuddy</a>, a script I wrote a while back to help with this sort of thing. And there hit my first snag, as I discovered that <a href="https://brew.sh" target="_blank">homebrew</a> didn't yet have native support. After jumping through few hoops to get homebrew setup via Rosetta 2, and my goto packages installed, I was on my way to downloading <a href="https://docs.docker.com/docker-for-mac/install/" target="_blank">Docker Desktop for Mac</a>.</p> <p>I naively expected Docker to "just work" as it was a touted feature, briefly mentioned during Apple's transition announcement and then later followed up in more detail during the <a href="https://appleinsider.com/articles/20/06/25/apples-federighi-and-joswiak-discuss-apple-silicon-ios-14-big-sur-and-more" target="_blank">AppleInsider interview</a>. Unfortunately, I soon came across an official <a href="https://www.docker.com/blog/apple-silicon-m1-chips-and-docker/" target="_blank">docker blog post</a> about Docker Desktop not being quite ready but was being worked on.</p> <h2>Hope: Apple support for Linux virtualization</h2><p>Impatient, I searched on and came across <a href="https://developer.apple.com/documentation/virtualization" target="_blank">Apple's developer documentation</a> for supporting Linux through virtualization. This was promising and I knew it was only a matter of time before someone built an Objective C or Swift wrapper around it.</p> <p>A few days later, I came across this well written article:&nbsp;<a href="https://finestructure.co/blog/2020/11/27/running-docker-on-apple-silicon-m1" target="_blank">Running Docker on Apple Silicon M1</a> which had a nice step-by-step tutorial to getting it setup using a project called <a href="https://github.com/evansm7/vftool" target="_blank">vftool</a> and the <a href="https://cdimage.ubuntu.com/focal/daily-live/current/focal-desktop-arm64.iso" target="_blank">ARM64 version of Ubuntu 20.04 image</a>. Following those steps, I was able to get docker running, albeit in a read-only live cd that had a small <a href="https://en.wikipedia.org/wiki/Copy-on-write" target="_blank">COW</a> filesystem. The <a href="https://finestructure.co/blog/2020/11/27/running-docker-on-apple-silicon-m1-follow-up">2nd follow up article</a> has steps to show how to connect to the docker daemon from docker cli running on macOS, thus giving something closer to what Docker Desktop for Mac had to offer.</p> <h2>Contribution: Getting full read/write support with data persistence</h2> <p>Some of the downsides to running off the livecd was that the default COW filesystem can quickly run out of diskspace as it was only about 1GB in size. As the COW filesystem is merely an overlay on top of a read-only squashfs filesystem, uninstalling packages won't help (in fact will eat into the COW space). Another downside was that in order to get Docker working properly, vfs filesystem driver needed to be configured and this was known to be less performant.</p> <p>Therefore I wanted to see if there was a way to install Ubuntu onto a read-write filesystem. Below are the steps I followed in order to achieve that. Please first read the above linked post to get vftool setup and kernel and initrd images extracted from the live CD iso from within macOS.</p> <p>Below is how my directories are structured, so you will need to adapt to your situation.</p> <div><img border="0" data-original-height="276" data-original-width="656" height="161" src="https://1.bp.blogspot.com/-POEwLh6n0wU/X9a2Z4sOXBI/AAAAAAAAUaM/s-L68_i-1CkoUpKJ3mZU1qKEq-4fVbWNQCLcBGAsYHQ/w382-h161/tree.png" width="382" /></div> <h3>Steps 1: Create a loopback disk image</h3><p>After testing a few disk sizes, I settled on a 10GB loopback disk image.</p><code>dd if=/dev/zero of=disk.img bs=1m count=10240 </code> <h3>Step 2: Create a temporary VM to install Ubuntu</h3><p>The next step is to boot into a VM similar to how the article I've linked explains. We use this VM to then manually install Ubuntu onto the loopback disk.img</p> <code>./vftool -k ./vmlinuz -i ./initrd-livecd -c ./focal-desktop-arm64.iso -d disk.img -m 4096 -a "console=hvc0"<br /></code> <p>On another terminal connect to the VM</p> <code>screen /dev/ttys002 </code> <h3>Step 3: Partition and mount the loopback disk</h3> <p>The disk should be mounted on to /dev/vda</p> <code>cfdisk /dev/vda<br /><br />Partition type: gpt<br />/dev/vd1 Linux filesystem </code> <p>Save and exit. Then format the partition as ext4</p> <code>mkfs.ext4 /dev/vda1 </code> <h3>Step 4: Mount new partition and copy files to it</h3><p>Mount and start copying files from /rofs which is where Ubuntu mounts the read-only squashfs file system.</p> <code>mount /dev/vd1 /mnt<br />cd /rofs<br />cp -axv . /mnt/ </code> <h3>Step 5: Chroot onto loopback filesystem to perform post install tasks</h3> <code>mount -t proc none /mnt/proc<br />mount -t sysfs sysfs /mnt/sys<br />mount -o bind /dev /mnt/dev<br />chroot /mnt </code> <p>Next lets set the /etc/fstab so it knows how to mount /</p> <code>editor /etc/fstab<br /># UNCONFIGURED FSTAB FOR BASE SYSTEM 0.0 0 0.0<br />0<br />UTC </code> <code>dpkg-reconfigure tzdata </code> <p>Let's also create a user for us to login and be able to sudo.</p><code>adduser bud<br />addgroup --system admin<br />adduser bud admin </code> <h3>Step 6: Making a new initrd</h3> <p>The initrd we extracted from the livecd is not suitable for booting off the loopback disk.img so we need to generate a new one. Still within the chrooted environment run the following:</p> <code>mkinitramfs -c gzip -o /boot/initrd.img-$(uname -r) </code> <p>Next we need to copy the newly generated initrd.img back onto our macOS filesystem. I did this by enabling SSH within macOS.</p> <div><img border="0" data-original-height="860" data-original-width="1318" height="248" src="https://1.bp.blogspot.com/-eXbnGkYXdwI/X9bAkjrg_EI/AAAAAAAAUaY/luYOyajLFAwHjNKTPTj1c8HxOXaekhJhgCLcBGAsYHQ/w380-h248/ssh-sharing.png" width="380" /></div> <code>scp /boot/initrd.img-$(uname -r)<br />bud@192.168.86.28:/Downloads<br /></code> <p>Then copied the file from Downloads to where the other files were.</p> <h3>Step 7: Exit and unmount from chrooted environment</h3> <p><code>exit<br />umount /mnt/root/sys<br />umount /mnt/root/proc<br />umount /mnt/root/dev<br />umount /mnt </code> </p><p>Then shutdown the VM properly by issuing a poweroff</p> <code>sudo poweroff </code> <h3>Step 8: Ready to launch the new persistent VM</h3><p>We can now get rid of the cdrom image and boot directly on to the disk.img using the same kernel and new initrd.img-5.4.0-56-generic image.</p> <code>./vftool -k ./vmlinuz -i ./initrd.img-5.4.0-56-generic -d disk.img -m 4096 -a "console=hvc0 root=/dev/vda1" </code> <p>From another terminal...</p><code>screen /dev/ttys002 </code> <p>We should now be able to login using the account you created within the chrooted environment.</p> <h3>Step 9: Setting up SSH</h3><p>It's far easier to work within an SSH session that within the screen session and SSH can also be used to link docker cli running on macOS to connect to the daemon running inside the VM (more on this later)</p> <code>sudo apt install openssh-server </code> <p>Obtain the IP address within the VM and try connecting to it.</p> <code>ip addr show dev enp0s1 | grep 'inet '<br />ssh bud@192.168.64.13 </code> <p>Copy your macOS account's SSH key to the remote VM in order to enable password-less login, which is also needed by docker cli when connecting from the Mac.</p> <code>ssh-copy-id bud@192.168.64.13 </code> <h3>Step 10: Setting up Docker inside VM</h3> <p>These steps are copied from the linked article which are adapted from docker's official installation guide.</p> <code>sudo apt-get install apt-transport-https ca-certificates \<br />    curl  gnupg-agent software-properties-common<br /><br />curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br /><br />sudo add-apt-repository \<br />   "deb [arch=arm64] https://download.docker.com/linux/ubuntu \<br />   $(lsb_release -cs) \<br />   stable"<br /><br />sudo apt-get update<br />sudo apt-get install docker-ce docker-ce-cli containerd.io<br /></code> <p>To make it easy to run docker commands as the user I added myself to the docker group.</p> <code>sudo usermod -aG docker ${USER}<br />su - ${USER} </code> <p>Now logout and log back in for the new group to take effect. Docker should now be running properly.</p> <code>docker run --rm hello-world </code> <h3>Step 11: Setting up Docker cli to connect to VM</h3><p>For a near Docker for Mac like experience, we need to install docker cli on macOS. Unfortunately at the time of writing, this needs to be installed via Rosetta 2. I used homebrew to accomplish this, but you could also just <a href="https://docs.docker.com/engine/install/binaries/" target="_blank">download the binary directly</a> from Docker Inc.</p> <code>  arch -x86_64 brew install docker </code> <p>We then create a docker context and switch to it to seamlessly connect to the docker daemon running inside the VM.</p> <code>docker context create myvm --docker "host=ssh://bud@192.168.64.13"<br />docker context use myvm<br />docker run --rm hello-world </code><p>You should now be able to issue docker commands from within macOS.</p> <h3>Step 12: Uninstall gnome desktop (optional)</h3><p>Finally, I got rid of gnome desktop to reclaim more space as everything is running via the terminal. When trying this I ran into an issue with the&nbsp;flash-kernel package so you might want to first uninstall it.</p> <code>sudo dpkg -r flash-kernel<br /><br />sudo apt purge adwaita-icon-theme gedit-common gir1.2-gdm-1.0 \<br />gir1.2-gnomebluetooth-1.0 gir1.2-gnomedesktop-3.0 gir1.2-goa-1.0 \<br />gnome-accessibility-themes gnome-bluetooth gnome-calculator gnome-calendar \<br />gnome-characters gnome-control-center gnome-control-center-data \<br />gnome-control-center-faces gnome-desktop3-data \<br />gnome-font-viewer gnome-getting-started-docs gnome-getting-started-docs-ru \<br />gnome-initial-setup gnome-keyring gnome-keyring-pkcs11 gnome-logs \<br />gnome-mahjongg gnome-menus gnome-mines gnome-online-accounts \<br />gnome-power-manager gnome-screenshot gnome-session-bin gnome-session-canberra \<br />gnome-session-common gnome-settings-daemon gnome-settings-daemon-common \<br />gnome-shell gnome-shell-common gnome-shell-extension-appindicator \<br />gnome-shell-extension-desktop-icons gnome-shell-extension-ubuntu-dock \<br />gnome-startup-applications gnome-sudoku gnome-system-monitor gnome-terminal \<br />gnome-terminal-data gnome-themes-extra gnome-themes-extra-data gnome-todo \<br />gnome-todo-common gnome-user-docs gnome-user-docs-ru gnome-video-effects \<br />language-pack-gnome-en language-pack-gnome-en-base language-pack-gnome-ru \<br />language-pack-gnome-ru-base language-selector-gnome libgail18 libgail18 \<br />libgail-common libgail-common libgnome-autoar-0-0 libgnome-bluetooth13 \<br />libgnome-desktop-3-19 libgnome-games-support-1-3 libgnome-games-support-common \<br />libgnomekbd8 libgnomekbd-common libgnome-menu-3-0 libgnome-todo libgoa-1.0-0b \<br />libgoa-1.0-common libpam-gnome-keyring libsoup-gnome2.4-1 libsoup-gnome2.4-1 \<br />nautilus-extension-gnome-terminal pinentry-gnome3 yaru-theme-gnome-shell<br />sudo apt autopurge </code> <h2>Conclusion</h2><p>This was a fun exercise and if you're impatient waiting for official support from Docker Inc. or just want to try it for the fun of it, go ahead. Maybe you can extend the setup and tackle other problems I've yet to encounter. Else it might be best to just wait a bit longer as official support will be coming sooner rather than later.</p><p></p><p></p>